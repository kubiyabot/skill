//! Script Generator - Generate executable wrapper scripts
//!
//! Generates bash scripts that wrap `skill run` for each tool.
//! These scripts provide a fallback execution method when MCP is not available
//! (e.g., on claude.ai).

use anyhow::{Context, Result};
use std::fs;
use std::os::unix::fs::PermissionsExt;
use std::path::Path;

use super::types::{ClaudeSkill, ClaudeTool};

/// Generates wrapper scripts for skill tools
pub struct ScriptGenerator {
    skill_name: String,
}

impl ScriptGenerator {
    /// Create a new script generator for a skill
    pub fn new(skill_name: &str) -> Self {
        Self {
            skill_name: skill_name.to_string(),
        }
    }

    /// Generate all scripts for a skill
    pub fn generate(&self, skill: &ClaudeSkill, output_dir: &Path) -> Result<Vec<String>> {
        let scripts_dir = output_dir.join(&skill.name).join("scripts");
        fs::create_dir_all(&scripts_dir)
            .with_context(|| format!("Failed to create scripts directory: {}", scripts_dir.display()))?;

        let mut generated = Vec::new();

        for tool in &skill.tools {
            let script_path = scripts_dir.join(format!("{}.sh", tool.name));
            let script_content = self.generate_tool_script(tool);

            fs::write(&script_path, &script_content)
                .with_context(|| format!("Failed to write script: {}", script_path.display()))?;

            // Make executable
            let mut perms = fs::metadata(&script_path)?.permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&script_path, perms)?;

            generated.push(tool.name.clone());
        }

        Ok(generated)
    }

    /// Generate a script for a single tool
    fn generate_tool_script(&self, tool: &ClaudeTool) -> String {
        let mut script = String::new();

        // Shebang
        script.push_str("#!/bin/bash\n");

        // Header comment
        script.push_str(&format!(
            "# {}/scripts/{}.sh - Generated by Skill Engine\n",
            self.skill_name, tool.name
        ));
        script.push_str("#\n");
        script.push_str(&format!("# {}\n", tool.description));
        script.push_str("#\n");

        // Usage
        script.push_str("# Usage:\n");
        script.push_str(&format!(
            "#   ./{}.sh {}\n",
            tool.name,
            self.format_usage_args(&tool.parameters)
        ));
        script.push_str("#\n");

        // Parameters documentation
        if !tool.parameters.is_empty() {
            script.push_str("# Parameters:\n");
            for param in &tool.parameters {
                let required = if param.required { "(required)" } else { "(optional)" };
                let default = param
                    .default_value
                    .as_ref()
                    .map(|v| format!(" [default: {}]", v))
                    .unwrap_or_default();

                script.push_str(&format!(
                    "#   {:<15} - {} {}{}\n",
                    param.name, param.description, required, default
                ));
            }
            script.push_str("#\n");
        }

        // Script body
        script.push_str("\nset -euo pipefail\n\n");

        // Help flag handling
        script.push_str("# Show help if requested\n");
        script.push_str("if [[ \"${1:-}\" == \"-h\" || \"${1:-}\" == \"--help\" ]]; then\n");
        script.push_str(&format!(
            "    echo \"Usage: ./{}.sh {}\"\n",
            tool.name,
            self.format_usage_args(&tool.parameters)
        ));
        script.push_str(&format!("    echo \"\"\n"));
        script.push_str(&format!("    echo \"{}\"\n", tool.description));

        if !tool.parameters.is_empty() {
            script.push_str("    echo \"\"\n");
            script.push_str("    echo \"Parameters:\"\n");
            for param in &tool.parameters {
                let required = if param.required { "(required)" } else { "(optional)" };
                script.push_str(&format!(
                    "    echo \"  {:<15} {} {}\"\n",
                    param.name, param.description, required
                ));
            }
        }

        script.push_str("    exit 0\n");
        script.push_str("fi\n\n");

        // Execute skill run
        script.push_str("# Execute the skill tool\n");
        script.push_str(&format!(
            "exec skill run {} {} \"$@\"\n",
            self.skill_name, tool.name
        ));

        script
    }

    /// Format usage arguments for documentation
    fn format_usage_args(&self, parameters: &[super::types::ClaudeToolParameter]) -> String {
        if parameters.is_empty() {
            return "[args...]".to_string();
        }

        parameters
            .iter()
            .map(|p| {
                if p.required {
                    format!("{}=<value>", p.name)
                } else {
                    format!("[{}=<value>]", p.name)
                }
            })
            .collect::<Vec<_>>()
            .join(" ")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::commands::claude_bridge::types::{ClaudeToolParameter, SkillRuntimeType, ToolExample};
    use std::collections::HashMap;
    use tempfile::TempDir;

    // === Script Content Tests ===

    #[test]
    fn test_generate_tool_script_basic() {
        let gen = ScriptGenerator::new("kubernetes");

        let tool = ClaudeTool {
            name: "get".to_string(),
            description: "Get Kubernetes resources".to_string(),
            parameters: vec![
                ClaudeToolParameter {
                    name: "resource".to_string(),
                    param_type: "string".to_string(),
                    description: "Resource type".to_string(),
                    required: true,
                    default_value: None,
                    enum_values: None,
                },
                ClaudeToolParameter {
                    name: "namespace".to_string(),
                    param_type: "string".to_string(),
                    description: "Kubernetes namespace".to_string(),
                    required: false,
                    default_value: Some("default".to_string()),
                    enum_values: None,
                },
            ],
            examples: vec![],
            category: Some("Read Operations".to_string()),
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        // Check shebang
        assert!(script.starts_with("#!/bin/bash\n"));

        // Check exec command
        assert!(script.contains("skill run kubernetes get"));

        // Check parameters
        assert!(script.contains("resource=<value>"));
        assert!(script.contains("[namespace=<value>]"));

        // Check error handling
        assert!(script.contains("set -euo pipefail"));
    }

    #[test]
    fn test_generate_tool_script_no_parameters() {
        let gen = ScriptGenerator::new("test");

        let tool = ClaudeTool {
            name: "list_all".to_string(),
            description: "List all items".to_string(),
            parameters: vec![],
            examples: vec![],
            category: None,
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        assert!(script.contains("#!/bin/bash"));
        assert!(script.contains("skill run test list_all"));
        assert!(script.contains("[args...]"));
    }

    #[test]
    fn test_generate_tool_script_header_comment() {
        let gen = ScriptGenerator::new("docker");

        let tool = ClaudeTool {
            name: "ps".to_string(),
            description: "List running containers".to_string(),
            parameters: vec![],
            examples: vec![],
            category: None,
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        // Check header comments
        assert!(script.contains("# docker/scripts/ps.sh - Generated by Skill Engine"));
        assert!(script.contains("# List running containers"));
    }

    #[test]
    fn test_generate_tool_script_help_flag() {
        let gen = ScriptGenerator::new("test");

        let tool = ClaudeTool {
            name: "help_test".to_string(),
            description: "Test help output".to_string(),
            parameters: vec![
                ClaudeToolParameter {
                    name: "param1".to_string(),
                    param_type: "string".to_string(),
                    description: "First parameter".to_string(),
                    required: true,
                    default_value: None,
                    enum_values: None,
                },
            ],
            examples: vec![],
            category: None,
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        // Check help flag handling
        assert!(script.contains("if [[ \"${1:-}\" == \"-h\" || \"${1:-}\" == \"--help\" ]]; then"));
        assert!(script.contains("exit 0"));
        assert!(script.contains("echo \"Parameters:\""));
    }

    #[test]
    fn test_generate_tool_script_parameter_documentation() {
        let gen = ScriptGenerator::new("test");

        let tool = ClaudeTool {
            name: "tool".to_string(),
            description: "Test tool".to_string(),
            parameters: vec![
                ClaudeToolParameter {
                    name: "required".to_string(),
                    param_type: "string".to_string(),
                    description: "Required param".to_string(),
                    required: true,
                    default_value: None,
                    enum_values: None,
                },
                ClaudeToolParameter {
                    name: "optional".to_string(),
                    param_type: "string".to_string(),
                    description: "Optional param".to_string(),
                    required: false,
                    default_value: Some("default_value".to_string()),
                    enum_values: None,
                },
            ],
            examples: vec![],
            category: None,
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        // Check parameter documentation in comments
        assert!(script.contains("# Parameters:"));
        assert!(script.contains("required"));
        assert!(script.contains("(required)"));
        assert!(script.contains("optional"));
        assert!(script.contains("(optional)"));
        assert!(script.contains("[default: default_value]"));
    }

    #[test]
    fn test_generate_tool_script_exec_command() {
        let gen = ScriptGenerator::new("myskill");

        let tool = ClaudeTool {
            name: "mytool".to_string(),
            description: "My tool".to_string(),
            parameters: vec![],
            examples: vec![],
            category: None,
            streaming: false,
        };

        let script = gen.generate_tool_script(&tool);

        // Check exec command format
        assert!(script.contains("exec skill run myskill mytool \"$@\""));
    }

    // === Usage Args Formatting Tests ===

    #[test]
    fn test_format_usage_args_empty() {
        let gen = ScriptGenerator::new("test");
        let usage = gen.format_usage_args(&[]);
        assert_eq!(usage, "[args...]");
    }

    #[test]
    fn test_format_usage_args_required_only() {
        let gen = ScriptGenerator::new("test");

        let params = vec![
            ClaudeToolParameter {
                name: "param1".to_string(),
                param_type: "string".to_string(),
                description: "First".to_string(),
                required: true,
                default_value: None,
                enum_values: None,
            },
        ];

        let usage = gen.format_usage_args(&params);
        assert_eq!(usage, "param1=<value>");
    }

    #[test]
    fn test_format_usage_args_optional_only() {
        let gen = ScriptGenerator::new("test");

        let params = vec![
            ClaudeToolParameter {
                name: "param1".to_string(),
                param_type: "string".to_string(),
                description: "First".to_string(),
                required: false,
                default_value: Some("default".to_string()),
                enum_values: None,
            },
        ];

        let usage = gen.format_usage_args(&params);
        assert_eq!(usage, "[param1=<value>]");
    }

    #[test]
    fn test_format_usage_args_mixed() {
        let gen = ScriptGenerator::new("test");

        let params = vec![
            ClaudeToolParameter {
                name: "required_param".to_string(),
                param_type: "string".to_string(),
                description: "A required param".to_string(),
                required: true,
                default_value: None,
                enum_values: None,
            },
            ClaudeToolParameter {
                name: "optional_param".to_string(),
                param_type: "string".to_string(),
                description: "An optional param".to_string(),
                required: false,
                default_value: Some("default".to_string()),
                enum_values: None,
            },
        ];

        let usage = gen.format_usage_args(&params);
        assert_eq!(usage, "required_param=<value> [optional_param=<value>]");
    }

    #[test]
    fn test_format_usage_args_multiple_required() {
        let gen = ScriptGenerator::new("test");

        let params = vec![
            ClaudeToolParameter {
                name: "param1".to_string(),
                param_type: "string".to_string(),
                description: "First".to_string(),
                required: true,
                default_value: None,
                enum_values: None,
            },
            ClaudeToolParameter {
                name: "param2".to_string(),
                param_type: "string".to_string(),
                description: "Second".to_string(),
                required: true,
                default_value: None,
                enum_values: None,
            },
        ];

        let usage = gen.format_usage_args(&params);
        assert_eq!(usage, "param1=<value> param2=<value>");
    }

    // === Full Generation Tests ===

    #[test]
    fn test_generate_creates_scripts_directory() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("test-skill");

        let skill = ClaudeSkill {
            name: "test-skill".to_string(),
            description: "Test".to_string(),
            tools: vec![],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Wasm,
        };

        let result = gen.generate(&skill, temp.path());
        assert!(result.is_ok());

        let scripts_dir = temp.path().join("test-skill/scripts");
        assert!(scripts_dir.exists());
    }

    #[test]
    fn test_generate_creates_script_files() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("test");

        let skill = ClaudeSkill {
            name: "test".to_string(),
            description: "Test".to_string(),
            tools: vec![
                ClaudeTool {
                    name: "tool1".to_string(),
                    description: "First tool".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
                ClaudeTool {
                    name: "tool2".to_string(),
                    description: "Second tool".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
            ],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Native,
        };

        let result = gen.generate(&skill, temp.path()).unwrap();
        assert_eq!(result.len(), 2);

        let scripts_dir = temp.path().join("test/scripts");
        assert!(scripts_dir.join("tool1.sh").exists());
        assert!(scripts_dir.join("tool2.sh").exists());
    }

    #[test]
    fn test_generate_scripts_are_executable() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("test");

        let skill = ClaudeSkill {
            name: "test".to_string(),
            description: "Test".to_string(),
            tools: vec![
                ClaudeTool {
                    name: "exec_test".to_string(),
                    description: "Executable test".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
            ],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Docker,
        };

        gen.generate(&skill, temp.path()).unwrap();

        let script_path = temp.path().join("test/scripts/exec_test.sh");
        let metadata = fs::metadata(&script_path).unwrap();
        let permissions = metadata.permissions();

        // Check executable bit is set (0o755 = rwxr-xr-x)
        assert_eq!(permissions.mode() & 0o111, 0o111);
    }

    #[test]
    fn test_generate_script_content_correct() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("myskill");

        let skill = ClaudeSkill {
            name: "myskill".to_string(),
            description: "My skill".to_string(),
            tools: vec![
                ClaudeTool {
                    name: "get_data".to_string(),
                    description: "Get some data".to_string(),
                    parameters: vec![
                        ClaudeToolParameter {
                            name: "id".to_string(),
                            param_type: "string".to_string(),
                            description: "Data ID".to_string(),
                            required: true,
                            default_value: None,
                            enum_values: None,
                        },
                    ],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
            ],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Wasm,
        };

        gen.generate(&skill, temp.path()).unwrap();

        let script_content = fs::read_to_string(temp.path().join("myskill/scripts/get_data.sh")).unwrap();

        assert!(script_content.starts_with("#!/bin/bash\n"));
        assert!(script_content.contains("skill run myskill get_data"));
        assert!(script_content.contains("id=<value>"));
        assert!(script_content.contains("Get some data"));
    }

    #[test]
    fn test_generate_returns_tool_names() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("test");

        let skill = ClaudeSkill {
            name: "test".to_string(),
            description: "Test".to_string(),
            tools: vec![
                ClaudeTool {
                    name: "tool_a".to_string(),
                    description: "Tool A".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
                ClaudeTool {
                    name: "tool_b".to_string(),
                    description: "Tool B".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
            ],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Native,
        };

        let generated = gen.generate(&skill, temp.path()).unwrap();

        assert_eq!(generated.len(), 2);
        assert!(generated.contains(&"tool_a".to_string()));
        assert!(generated.contains(&"tool_b".to_string()));
    }

    #[test]
    fn test_generate_empty_tools() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("test");

        let skill = ClaudeSkill {
            name: "test".to_string(),
            description: "Test".to_string(),
            tools: vec![],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Wasm,
        };

        let generated = gen.generate(&skill, temp.path()).unwrap();
        assert_eq!(generated.len(), 0);
    }

    #[test]
    fn test_script_generator_new() {
        let gen = ScriptGenerator::new("test-skill");
        assert_eq!(gen.skill_name, "test-skill");
    }

    #[test]
    fn test_generate_with_special_characters_in_name() {
        let temp = TempDir::new().unwrap();
        let gen = ScriptGenerator::new("my-skill");

        let skill = ClaudeSkill {
            name: "my-skill".to_string(),
            description: "Test".to_string(),
            tools: vec![
                ClaudeTool {
                    name: "tool_with_underscore".to_string(),
                    description: "Tool".to_string(),
                    parameters: vec![],
                    examples: vec![],
                    category: None,
                    streaming: false,
                },
            ],
            categories: HashMap::new(),
            when_to_use: vec![],
            runtime: SkillRuntimeType::Wasm,
        };

        let result = gen.generate(&skill, temp.path());
        assert!(result.is_ok());

        let script_path = temp.path().join("my-skill/scripts/tool_with_underscore.sh");
        assert!(script_path.exists());
    }
}
